# 计算机基础知识
## C++
### 语法基础

#### 对于C/C++编写的程序，从源代码到可执行文件的过程
1. 预处理，产生.ii文件 g++ -E
2. 编译，产生汇编文件(.s文件) g++ -s
3. 汇编，产生目标文件(.o或.obj文件) g++ -c
4. 链接,产生可执行文件(.out或.exe文件) g++ -o

#### 声明和定义的区别
声明规定变量的类型和名字，使得名字为程序所知；而定义还申请存储空间，负责创建与名字关联的实体，也可能会为变量赋予一个初始值

#### 指针和引用的区别
1. 指针保存的是指向对象的地址，引用相当于变量的别名
2. 引用在定义的时候必须初始化，指针没有这个要求
3. 指针可以改变地址，引用必须从一而终
4. 不存在空应引用，但是存在空指针NULL，相对而言引用更加安全
5. 引用的创建不会调用类的拷贝构造函数  

#### new/delete与malloc/free的区别
1. new是运算符，malloc是C语言库函数
2. new可以重载，malloc不能重载
3. new的变量是数据类型，malloc的是字节大小
4. new可以调用构造函数，delete可以调用析构函数，malloc/free不能
5. new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化
6. malloc分配的内存不够的时候可以使用realloc扩容，new没有这样的操作
7. new内存分配失败抛出bad_malloc，malloc内存分配失败返回NULL值 、

#### define/const/inline的区别  
- 本质：define只是字符串替换，const参与编译运行，具体的
  - define不会做类型检查，const拥有类型，会执行相应的类型检查
  - define仅仅是宏替换，不占用内存，而const会占用内存、
  - const内存效率更高，编译器通常将const变量保存在符号表中，而不会分配存储空间，这使得它成为一个编译期间的常量，没有存储和读取的操作  
- 本质：define只是字符串替换，inline由编译器控制，具体的
  - 内联函数在编译时展开，而宏是由预处理器对宏进行展开
  - 内联函数会检查参数类型，宏定义不检查函数参数 ，所以内联函数更安全。
  - 宏不是函数，而inline函数是函数
  - 宏在定义时要小心处理宏参数，（一般情况是把参数用括弧括起来）。  

#### 构造函数为什么不能定义为虚函数，析构函数为什么可以？
1. 虚函数的执行依赖于虚函数表。而虚函数表需要在构造函数中进行初始化工作，即初始化vptr，让他指向正确的虚函数表。而在构造对象期间，虚函数表还没有被初始化，将无法进行
2. 在类的继承中，如果有基类指针指向派生类，那么用基类指针delete时，如果不定义成虚函数，派生类中派生的那部分无法析构
3. 构造函数不要调用虚函数。在基类构造的时候，虚函数是非虚，不会走到派生类中，既是采用的静态绑定。显然的是：当我们构造一个子类的对象时，先调用基类的构造函数，构造子类中基类部分，子类还没有构造，还没有初始化，如果在基类的构造中调用虚函数，如果可以的话就是调用一个还没有被初始化的对象，那是很危险的，所以C++中是不可以在构造父类对象部分的时候调用子类的虚函数实现。但是不是说你不可以那么写程序，你这么写，编译器也不会报错。只是你如果这么写的话编译器不会给你调用子类的实现，而是还是调用基类的实现

#### 字节对齐的原则，如何强制不对齐？
1. k字节基本类型以k字节倍数偏移量对齐,自定义结构体则以结构体中最高p字节基本类型的p字节倍数偏移量对齐
2. 变量存储的起始位置是该变量大小的整数倍
3. 结构体总的大小是其最大元素的整数倍，不足的后面要补齐
4. 结构体中包含结构体，从结构体中最大元素的整数倍开始存
5. 如果加入pragma pack(n) ，取n和变量自身大小较小的一个。
6. #pragma pack()，取消对齐，按照编译器的优化对齐方式对齐

#### 重写、重载与隐藏的区别
1. 重载的函数都是在类内的。只有参数类型或者参数个数不同，重载不关心返回值的类型
2. 覆盖（重写）派生类中重新定义的函数，其函数名，返回值类型，参数列表都跟基类函数相同，并且基类函数前加了virtual关键字
3. 隐藏是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数。有两种情况
   - 参数列表不同，不管有无virtual关键字，都是隐藏
   - 参数列表相同，但是无virtual关键字，也是隐藏。

#### 静态链接和动态链接的区别
1. 静态链接：在编译时直接将需要的执行代码拷贝到调用处。优点是在程序发布的时候就不需要依赖库，也就是不再需要带着库一块发布，程序可以独立执行，但是体积可能会相对大些
2. 动态链接：在编译的时候不直接拷贝可执行代码，而是通过记录一些列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定代码时，区共享执行内存中已经加载的动态库可执行代码，最终达到运行时链接的目的。优点是多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝;缺点是由于是运行时加载，可能会影响程序的前期执行。

#### C++如何创建一个类，使得只能在堆或者栈上创建
- 只能在堆上生成对象：将析构函数设置为私有
  - 原因：C++是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。  
- 只能在栈上生成对象：将new 和 delete 重载为私有
  - 原因：在堆上生成对象，使用new关键词操作，其过程分为两阶段：第一阶段，使用new在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将new操作设置为私有，那么第一阶段就无法完成，就不能够再堆上生成对象。

#### 一个空类sizeof是多少，为什么？
这是因为空类同样可以被实例化，如果定义对空类取sizeof()的值为0，那么该空的类或结构体实例化出很多实例时，在内存地址上就不能区分该类实例化出的实例。所以，为了实现每个实例在内存中都有一个独一无二的地址，编译器往往会给一个空类隐含的加一个字节，这样空类在实例化后在内存得到了独一无二的地址，所以空类所占的内存大小是1个字节。

#### C++拷贝构造函数
如果一个构造函数的第一个参数是自身类类型的引用，且任何外参数都有默认值，则此构造函数是拷贝构造函数

#### 枚举类型的大小
枚举成员的默认类型是int，在定义或声明时可以指定数据类型，但前置声明和定义对该enum是否限定作用域、enum的大小保持一致。
```
enum class/struct name [:type]{ // 限定了作用域 c++11, type表示数据类型（大小）
  /// members;
};
enum [name] [:type]{
  /// members;
};
```

#### `int *(&array)[10] = pts`解释
int *(&array)[10] = pts：按照由内向外的顺序，首先知道array是个引用，然后观察右边知道array引用的对象是一个大小为10的数组，最后左边知道，数组的类型是指向int的指针。

#### sizeof操作符
sizeof操作符返回的是某种类型的对象占用内存的字节数。普通指针的类型的对象存储指针值，在32位系统中是4个字节，在64位系统中是8个字节。内置数组尽管可以隐士转换为指针，但本身不是指针类型。如果sizeof作用于数组，将返回整个数组的所占内存的大小；比如内置数组的别名`typedef int Arr[10];`，而指针的别名位`typedef int* Ptr;`。如果要定义一个指向内置数组的指针，则`int (*ptr)[10] = &arr;`

#### union和结构体的区别与联系？
联合体是几个不同类型的变量共占一段内存，它们不能同时存在；结构体把不同类型的数据组合成一个整体，各成员都占有自己的内存空间，它们是同时存在的。所在任何同一时刻, union中只存放了一个被选中的成员, 而struct的所有成员都存在。对于union的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于struct的不同成员赋值是互不影响的。一个struct变量的总长度和所有成员长度有关。Union变量的长度等于最长的成员的长度。

#### 引用声明为null的空指针会触发什么操作？
解引用空指针时，会导致程序崩溃（Segmentation fault）。

### 关键字

#### const 关键字的作用  
1. 欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了
2. 对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const
3. 在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值
4. 对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变
5. 对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值“; 

#### static关键字的作用  
1. 修饰局部变量。该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束（初始化只进行一次）；虽然用static对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块
2. 修饰全局变量。对于一个全局变量，它既可以在本源文件中被访问到，也可以在同一个工程的其它源文件中被访问(只需用extern进行声明即可)
3. 修饰函数。用static修饰函数的话，情况与修饰全局变量大同小异，就是改变了函数的作用域
4. 在class内的static全局变量可以被class内所有函数访问，但不能被class外其他函数访问，对类的所有对象只有一份复制
5. 在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量  

#### extern关键字的作用  
1. extern可置于变量或者函数前，以表示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。另外，extern也可用来进行链接指定
2. 修饰函数。如果函数的声明中带有关键字extern，仅仅是暗示这个函数可能在别的源文件里定义，没有其它作用
3. extern “C”。 C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。  

#### volatile关键字的作用  
1. volatile是变量修饰符，其修饰的变量具有可见性，volatile不保证原子性，同时volatile禁止指令重排，使用volatile修饰符的变量是直接读写主存
2. 一个参数可以即是const又是volatile的吗？可以，一个例子是只读状态寄存器，是volatile是因为它可能被意想不到的被改变，是const告诉程序不应该试图去修改他 

### 虚函数与多态

#### 多态的实现方法都有哪几种
- 重载
  - 如果同一作用域（一个类就是一个作用域，具有继承关系的类是在不用的作用域）的几个函数名字相同但形参列表不同（参数个数、类型、顺序），称之为函数重载
  - 在C++的底层，有重命名机制，比如下面这个函数。底层的重命名机制将函数根据参数的个数，参数的类型，返回值的类型都做了重新命名。在底层，不同的重载类型具有不同的函数名。
- 模板
  - 所谓函数模板，实际上是建立一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟的类型来代表。这个通用函数就称为函数模板。在调用函数时系统会根据实参的类型来取代模板中的虚拟类型，从而实现了不同函数的功能。
- 虚函数（覆盖或重写）
  - 派生类中的函数只有与基类虚函数的调用形式一样（有一个例外，返回对象本身的指针或应用）才构成覆盖（重写）
  - 具有虚函数的类，有一个指针，通常称为`vptr`，指向一个某表格（virtual table）。表格中持有类的虚函数地址。这些地址在编译时确定，是固定不变的。每个虚函数都被指派一个表格索引值。比如说，有这么一个例子：
  ```
  base_ptr->z();
  ```
  每次调用z()时，我们并不知道base_ptr指向的真正类型。然而我们知道，经过base_ptr可以存取到该对象的virtual table。并且，在表格特定的偏移处，有z()的地址。比如说是在slot 4中，则编译器可以将上述调用转换为：
  ```
  (*base_ptr->vptr[4](base_ptr));
  ```
  执行期唯一确定base_ptr，不同的base_ptr调用不同的实例。

#### 静态函数和虚函数调用时的区别

### STL

#### STL迭代器类型
有五种迭代器
- 输入迭代器（Input Iterator）：只能读取迭代器指向的元素，并且迭代器只能++（不能访问遍历过的元素）
- 输出迭代器（Output Iterator）：可以改变迭代器指向的元素，并且迭代器只能++
- 前进迭代器（Forward Iterator）：只能++，但是可以多次访问
- 双向迭代器（Bidirectional Iterator）：可以++和--
- 随机访问迭代器（Random Iterator）：可以随机访问

#### vector list map 介绍一下，并说vector和list有什么不同
vector的底层是数组，是一段连续的地址空间，list底层是链表，节点间的地址空间不连续，map的底层是红黑树。

#### vector内存是怎么增长的
当向vector插入元素并且预分配的内存空间用完时，vector会重新申请一块更大的内存空间，其大小是当前大小的两倍。接着将待插入的元素插入到新的内存的适当位置处。然后讲原来的元素复制到新的空间。如果在拷贝的过程中出现异常，已经拷贝的元素会被析构，新申请的内存会被释放。最后释放原来的内存空间。

#### map里面为什么要用红黑树
可以在O(logn)时间内完成查找、插入和删除

#### vector迭代器失效的情况
vector的迭代器是指针的封装，当vector空间不足，重新申请内存是，指向原来内存的迭代器（指针）将失效

### C++11

#### C++11了解吗？说一下智能指针

### 设计模式
#### 了解过那些设计模式？（单例模式、reactor设计模式）
#### 那我问你点简单的，讲讲工厂和抽象工厂吧

#### 面向对象设计原则 (S.O.L.I.D)  
|简写|全拼|中文翻译|备注|
|:-:|:-:|:-:|:-:|
|SRP|The Single Resoposibility Principle|单一责任原则|修改一个类的原因只有一个（一个类负责一件事）|
|OCP|The Open Closed Principle|开放封闭原则|类应该对扩展开放，对修改关闭|
|LSP|The Liskov Substitution Principle|里氏替换原则|子类对象必须能够替换掉所有父类对象|
|ISP|The Interface Segregation Principle|接口分离原则|不应该强迫客户依赖于他们不用的方法|
|DIP|The Dependency Inversion Principle|依赖倒置原则|高层模块不应该依赖底层模块，二者都应该依赖于抽象;<br>抽象不应该依赖于细节，细节应该依赖于抽象|

## 算法与数据结构
### 数据结构
#### 二叉排序树
#### 平衡二叉树
#### 红黑树
#### B树
#### B+树
#### 跳表
#### 哈希表
#### 图（邻接矩阵、邻接链表）

### 算法
#### 写一个二分查找
#### 在一个旋转数组中查找一个数，要求时间复杂度为O(log(N))
#### 快速排序
#### 海量数据Bitmap
#### 海量数据排序（归并、基数排序）
#### 用两个栈实现队列
#### a的n次方怎么计算。
#### 自己实现一个atoi函数；
#### 如何判断一个二叉树是不是平衡二叉树
#### 输出当前数组数据中前两位大的数，提供优化方案和并行方案
#### 如何判断两个单向链表是否重叠？（使用快慢指针）
#### 快速排序的时间复杂度和空间复杂度？
#### 稳定的排序和不稳定的排序的概念？比如？

## 网络
### 基础
#### 简单介绍一下reactor设计模式？
#### TCP/UDP区别
#### 计算机网络模型有哪些，分别介绍
#### TCP三次握手和四次挥手，为什么是3次和4次
#### 第三次挥手客户端收到服务端发来的FIN后处于什么状态（time_wait），为什么要time wait？
#### ARP协议和相关操作
#### HTTP的常见方法，post与get差别，常见的请求头key-val对儿
#### http协议从输入一个URL到收到响应报文的整个过程；
#### TCP流量控制、滑动窗口
#### TCP数据传输过程中如何确认数据包未发送成功？有什么机制
#### IP包头中的TTL是什么意思
#### 客户端和服务器端创建socket链接流程
#### DNS协议的类型？

### 细节
#### 数据包从网卡到网卡要经历那些内存拷贝
#### HTTP和RPC的区别
#### 后台报504错误，分析原因如何解决
#### TCP数据包传到IP层会不会发生分包？
#### 三次握手里的序列号是从什么起？滑动窗口为什么是字节为单位滑动的？
#### 长连接和短连接？
#### 网络除FIN以外的异常中断还有那些？
#### TCP里多大的数据量传输要进行封装
#### HTTP协议连接过程，HTTPS连接过程
####  HTTP2和HTTP1区别，websocket建立连接过程
#### 对epoll的理解
#### IO模型有哪些
#### select,epoll区别
#### write和read操作中涉及的用户态的缓冲机制？

## 操作系统
### 基础
#### 线程与进程的区别，线程切换与进程切换？进程切换一定比线程切换开销大吗？（进程间线程切换）
#### 操作系统用户态和内核态
#### 操作系统内存是怎么管理的，虚拟内存是什么
#### 堆内存和栈内存区别与联系
#### 程序a调用程序b ，栈有什么变化
#### 堆和栈的增长方向
#### c程序的内存是怎么分配的
#### 解释僵尸进程，孤儿进程
#### 字节序的概念
#### 静态链接和动态链接的优缺点
#### 用户虚拟地址空间意义
#### 进程拥有的资源有那些
#### 父进程和子进程在内存上的关系

### 进程间通信与同步
#### 解释生产者消费者模型
#### 进程通信，线程同步方法
#### 讲讲信号和信号量，它们有什么区别
#### 进程间通信有哪些，哪些是你写过的
#### 解释信号量，条件变量，锁及相关
#### 进程间通信方式有哪些？（MPI，消息队列，管道等）
#### 管道通信相关操作和实现
#### 锁、进程同步和相关操作
### cache
#### cache原理和设计？
#### cache一致性？
#### 为什么要设置cache？硬件设备上是如何实现
#### buffer和cache的区别？
#### cache淘汰策略？可以用什么数据结构存储？为什么？优缺点是？（LRU 链表）
#### CACHE一致性如何解决；（MEIS状态机转移机制）
### linux
#### 内存中的栈的实现原理
#### 怎么样能让栈增长
#### linux中怎么查看堆栈
#### 解释一下.so文件
#### Linux写时复制技术
#### Linux中的map操作

### 应用
#### 线程级并行方式有哪些？（openmp pthread等）
#### 如何调整多线程的负载均衡
#### 假设有两个线程，一个线程怎么了解到另外一个线程是否崩溃；
#### 实现一个线程安全的queue的方法；（加锁，CAS队列，lock-free queue，mutex等）
#### 可能导致segmentation fault可能的操作？
#### Linux共享库的概念和意义
#### ork会有什么操作？
#### 用户调用write和read后操作系统会发生什么

## 数据库
### 原理
#### 事务的性质
#### 数据库的事务隔离级别
#### 脏读、不可重复读、幻读？
#### sql语句的执行过程，写完一条sql语句之后过程是怎样的。
#### 怎么加快sql查询？sql优化方法？
#### 数据库索引的数据结构？（B树）
#### 安全隔离级别设置为序列化，删除更新操作会产生幻读吗（问题记的有点模糊）
#### 索引最左原则，模糊查询一定索引失效?

### mysql
#### MySQL索引有哪些，基于数据结构的分类一下？基于hash和B+树的有什么区别、复杂度？什么时候要建立索引？


## 工具
### GDB
#### gdb调试的一些指令
#### 介绍GDB和常用调试命令；
#### 调试手段和流程？
#### 用过的调试工具有哪些？（GDB等）
#### 程序挂掉了，怎么调试？有什么工具？怎么做？
### Git
#### Git中fetch和pull的区别
#### Git中rebase和merge的区别？

### linux命令
#### 知道哪些Linux命令
#### Linux了解不，df dh区别，如何格式化磁盘，磁盘挂载过程，tcp丢包如何排查，docker是用什么实现的
#### tcpdump抓包
#### 说出LINUX命令：磁盘存储查询、内存使用查询、CPU信息查询
#### 解释TOP命令中各个数据的属性；
#### 内存泄漏如何查询？
#### 内存泄漏怎么查找？怎么处理？
#### 内存泄漏排查手段和可能的实现？
#### 内存泄漏？
#### 如何查看进程负载和内存泄漏？
#### top中的相关属性？load average？
#### vim开发的相关工具？
#### shell脚本中0,1,2的意思


## 其他
#### Python里的init方法与new方法的区别
#### Python导入一个包的过程