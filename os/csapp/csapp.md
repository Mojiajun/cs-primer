# 深入理解计算机系统

## ch9 虚拟内存
虚拟内存是操作提供的一种对主存的抽象概念，它为每个进程提供了一个大的、一致和私有的地址空间。通过一个很清晰的机制，虚拟内存提供了三个重要的能力：
1. 它将主存看成一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，高效地使用了主存;
2. 它为每个进程提供了一致的地址空间，从而简化了内存管理;
3. 它保护了每个进程的地址空间不被其他进程破化;

### 物理地址和虚拟地址
<img src="./imgs/ch9-vm-system.png">

### 虚拟内存作为缓存的工具
概念上而言，虚拟内存被组织为一个由磁盘上的N个连续字节大小的单元组成的数组，每个字节都有一个唯一的虚拟地址，作为到数组的索引。数组的内容被缓存在主存中。虚拟系统将虚拟内存分割为称为虚拟页的大小固定的块，类似地，物理内存被分割为物理页（也称为页帧），大小和虚拟页一致。

在任意时刻，虚拟页面的集合都分为三个不相交的子集：
1. 未分配的：虚拟系统还未分配（或者创建）的页。未分配的页没有任何数据和它们相关联，因此也就没有对应的磁盘空间。
2. 缓存的：当前已缓存在物理内存（主存）中的已分配页
3. 未缓存的：未缓冲在物理内存（主存）的已分配页

<img src='./imgs/ch9-vm-as-cache.png'>

#### 页表
虚拟内存系统必须有某种方法来判定一个虚拟页是否缓冲在物理内存的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到内存中，替换这个牺牲页

这些功能是由软硬件联合提供的，包括操作系统、内存管理单元（Memory Management Unit, MMU）中的地址翻译硬件和一个常驻内存的页表的数据结构。页表将虚拟页面映射到物理页，每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘和内存之间来回传送页。

页表就是一个页表条目（Page Table Entry, PTE）的数组，虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个PTE。

<img src='./imgs/ch9-page-table.png'>

### 虚拟内存作为内存管理的工具
<img src='./imgs/ch9-process-vms.png'>

操作系统为某个进程提供了独立的页表，因而也就是一个独立的虚拟地址空间。不同进程的虚拟地址可以映射到同一个共享物理页面上。虚拟系统简化了链接和加载、代码和数据共享，以及应用程序的内存分配
- 简化链接：独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。
- 简化加载：虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。要把目标文件中`.text`和`.data`数据加载到一个新创建的进程中，Linux加载器为代码和数据端分配虚拟页，把它们标记为无效的（未被缓存的），将页表条目指向目标文件的适当位置
- 简化共享：操作系统通过将不同进程中的适当的虚拟页面映射到相同的物理物理页面，从而安排多个进程共享这部分代码的一个副本，而不是在每个进程中都包含一份共享数据
- 简化内存分配：当一个运行在用户进程中的程序要求额外的堆空间时（malloc调用），操作系统分配K个连续的虚拟内存页面，并且将它们映射到物理内存中k个任意的物理页面，不要求连续

### 虚拟内存作为内存保护的工具
<img src='./imgs/ch9-page-protection.png'>

SUP位表示进程是否必须运行在内核模式（超级用户）下才能访问该页。如果一条指定违反了这些许可条件，那么CPU就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。Linux shell一般将这种异常报告为段错误（Segmentation Fault）

### 地址翻译
<img src='./imgs/ch9-address-translation.png'>

#### 页面命中
<img src='./imgs/ch9-page-hit.png'>

CPU硬件执行的步骤
1. 处理器生成一个虚拟地址，把它传送给MMU
2. MMU生成PTE地址，并请求从主存/高速缓冲得到它
3. 主存/高速缓冲向MMU返回PTE
4. MMU构造物理地址，把它传送给主存/高速缓冲
5. 主存/高速缓冲返回所请求的数据字给处理器

#### 缺页
<img src='./imgs/ch9-page-fault.png'>

硬件和操作系统协作执行步骤
1. 处理器生成一个虚拟地址，把它传送给MMU
2. MMU生成PTE地址，并请求从主存/高速缓冲得到它
3. 主存/高速缓冲向MMU返回PTE
4. PTE有效位是零，所以MMU触发了一次异常，将CPU转移给操作系统内核中的缺页异常处理程序
5. 缺页异常处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它写会磁盘
6. 缺页异常处理程序调入新的页面，并更新内存中的PTE
7. 缺页异常处理程序返回到原来的进程，再次执行导致缺页的指令。后面过程就是命中的处理步骤

#### 结合高速缓存（比如CPU和主存的L1缓存）的情况
<img src='./imgs/ch9-vm-with-cache.png'>

#### 利用TLB加速地址翻译
没有TLB（Translation Lookaside Buffer）的情况，每次CPU产生一个虚拟地址，MMU就必须区主存或高速缓冲中查阅一个PTE，以便将虚拟地址翻译为物理地址，如果从内存读取，代价是几十到几百个周期。如果PTE碰巧缓存在L1中，那么代价下降到1个或2个周期。TLB用来试图消除即使是1个或2个周期的开销。

<img src='./imgs/ch9-tlb.png'>

TLB是一个小的、虚拟地址的缓存，其中没一行都保存着一个有单个PTE组成的块。用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号（VPN）中提取出来的。如果TLB有2^t个组，那么TLB索引（TLBI）是由VPN的t个最低位组成的，而TLB标记（TLBT）是由VPN中剩余的位组成的。

<img src='./imgs/ch9-tlb-page-hit-and-fault.png'>

当TLB命中时（通常情况），所有的地址翻译步骤都是在芯片上的MMU中执行，因此非常快。其步骤如下：
1. CPU产生一个虚拟地址
2. 用VPN在TLB中查找PTE
3. TLB返回PTE
4. MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓冲/主存
5. 主存/高速缓冲返回所请求的数据字给处理器

#### 多级页表
<img src='./imgs/ch9-k-level-page-table.png'>

### Intel Core i7地址翻译
#### 内存系统
<img src='./imgs/ch9-i7-memory-system.png'>

#### 地址翻译
<img src='./imgs/ch9-i7-address-translation.png'>

### Linux虚拟内存系统
<img src='./imgs/ch9-linux-vm.png'>

Linux为每个进程维护了一个单独的虚拟地址空间，可分为内核虚拟内存和进程虚拟内存。Linux将虚拟内存组织成一些区域（也叫做段）的集合，一个区域就是就是已经分配的虚拟内存的连续片。每个存在的虚拟页面都保存在某个区域中，而不属于某个区域的虚拟页是不存在的，且不能被进程引用。内核为系统中的每个进程维护一个单独的`tast_struct`，任务结构中的一个条目指向`mm_struct`，它描述了虚拟内存的当前状态

<img src='./imgs/ch9-linux-mm-struct.png'>

### 内存映射
Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存的内容，这个过程称为内存映射。虚拟内存区域可以映射到两种类型的对象中的一种：
1. Linux文件系统中的普通文件
2. 匿名文件