# 计算机基础知识
## 语法基础

### 对于C/C++编写的程序，从源代码到可执行文件的过程
1. 预处理，产生.ii文件 g++ -E
2. 编译，产生汇编文件(.s文件) g++ -s
3. 汇编，产生目标文件(.o或.obj文件) g++ -c
4. 链接,产生可执行文件(.out或.exe文件) g++ -o

### 声明和定义的区别
声明规定变量的类型和名字，使得名字为程序所知；而定义还申请存储空间，负责创建与名字关联的实体，也可能会为变量赋予一个初始值

### 指针和引用的区别
1. 指针保存的是指向对象的地址，引用相当于变量的别名
2. 引用在定义的时候必须初始化，指针没有这个要求
3. 指针可以改变地址，引用必须从一而终
4. 不存在空应引用，但是存在空指针NULL，相对而言引用更加安全
5. 引用的创建不会调用类的拷贝构造函数  

### new/delete与malloc/free的区别
1. new是运算符，malloc是C语言库函数
2. operator new可以重载，malloc不能重载
3. new的变量是数据类型，malloc的是字节大小
4. new可以调用构造函数，delete可以调用析构函数，malloc/free不能
5. new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化
6. malloc分配的内存不够的时候可以使用realloc扩容，new没有这样的操作
7. new内存分配失败抛出bad_malloc，malloc内存分配失败返回NULL值 、

### define/const/inline的区别  
- 本质：define只是字符串替换，const参与编译运行，具体的
  - define不会做类型检查，const拥有类型，会执行相应的类型检查
  - define仅仅是宏替换，不占用内存，而const会占用内存、
  - const内存效率更高，编译器通常将const变量保存在符号表中，而不会分配存储空间，这使得它成为一个编译期间的常量，没有存储和读取的操作  
- 本质：define只是字符串替换，inline由编译器控制，具体的
  - 内联函数在编译时展开，而宏是由预处理器对宏进行展开
  - 内联函数会检查参数类型，宏定义不检查函数参数 ，所以内联函数更安全。
  - 宏不是函数，而inline函数是函数
  - 宏在定义时要小心处理宏参数，（一般情况是把参数用括弧括起来）。  

### 构造函数为什么不能定义为虚函数，析构函数为什么可以？
1. 虚函数的执行依赖于虚函数表。而虚函数表需要在构造函数中进行初始化工作，即初始化 vptr（虚表指针），让他指向正确的虚函数表。而在构造对象期间，虚函数表还没有被初始化，将无法进行
2. 在类的继承中，如果有基类指针指向派生类，那么用基类指针 delete 时，如果不定义成虚函数，派生类中派生的那部分无法析构
3. 构造函数不要调用虚函数。在基类构造的时候，虚函数是非虚，不会走到派生类中，既是采用的静态绑定。显然的是：当我们构造一个子类的对象时，先调用基类的构造函数，构造子类中基类部分，子类还没有构造，还没有初始化，如果在基类的构造中调用虚函数，如果可以的话就是调用一个还没有被初始化的对象，那是很危险的，所以C++中是不可以在构造父类对象部分的时候调用子类的虚函数实现。但是不是说你不可以那么写程序，你这么写，编译器也不会报错。只是你如果这么写的话编译器不会给你调用子类的实现，而是还是调用基类的实现

### 字节对齐的原则，如何强制不对齐？
1. k字节基本类型以k字节倍数偏移量对齐,自定义结构体则以结构体中最高p字节基本类型的p字节倍数偏移量对齐
2. 变量存储的起始位置是该变量大小的整数倍
3. 结构体总的大小是其最大元素的整数倍，不足的后面要补齐
4. 结构体中包含结构体，从结构体中最大元素的整数倍开始存
5. 如果加入pragma pack(n) ，取n和变量自身大小较小的一个。
6. #pragma pack()，取消对齐，按照编译器的优化对齐方式对齐

### 重写、重载与隐藏的区别
1. 重载的函数是在同一个作用域（类）中。只有参数类型或者参数个数不同，重载不关心返回值的类型
2. 覆盖（重写）派生类中重新定义的函数，其函数名，返回值类型，参数列表都跟基类函数相同，并且基类函数前加了 virtual 关键字
3. 隐藏是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数。有两种情况
   - 参数列表不同，不管有无 virtual 关键字，都是隐藏
   - 参数列表相同，但是无 virtual 关键字，也是隐藏。

### 静态链接和动态链接的区别
1. 静态链接：在编译时直接将需要的执行代码拷贝到调用处。优点是在程序发布的时候就不需要依赖库，也就是不再需要带着库一块发布，程序可以独立执行，但是体积可能会相对大些
2. 动态链接：在编译的时候不直接拷贝可执行代码，而是通过记录一些列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定代码时，区共享执行内存中已经加载的动态库可执行代码，最终达到运行时链接的目的。优点是多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝;缺点是由于是运行时加载，可能会影响程序的前期执行。

### C++如何创建一个类，使得只能在堆或者栈上创建
- 只能在堆上生成对象：将析构函数设置为私有或为删除的，并且提供资源释放函数
  - 原因：C++是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。  
- 只能在栈上生成对象：将 operator new 和 operator delete 重载为私有或为删除的
  - 原因：在堆上生成对象，使用new关键词操作，其过程分为两阶段：第一阶段，使用new在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将new操作设置为私有，那么第一阶段就无法完成，就不能够再堆上生成对象。

### 一个空类sizeof是多少，为什么？
这是因为空类同样可以被实例化，如果定义对空类取sizeof()的值为0，那么该空的类或结构体实例化出很多实例时，在内存地址上就不能区分该类实例化出的实例。所以，为了实现每个实例在内存中都有一个独一无二的地址，编译器往往会给一个空类隐含的加一个字节，这样空类在实例化后在内存得到了独一无二的地址，所以空类所占的内存大小是1个字节。

### C++拷贝构造函数
如果一个构造函数的第一个参数是自身类类型的引用，且任何外参数都有默认值，则此构造函数是拷贝构造函数

### 枚举类型的大小
枚举成员的默认类型是int，在定义或声明时可以指定数据类型，但前置声明和定义对该enum是否限定作用域、enum的大小保持一致。
```
enum class/struct name [:type]{ // 限定了作用域 c++11, type表示数据类型（大小）
  /// members;
};
enum [name] [:type]{
  /// members;
};
```

### `int *(&array)[10] = pts`解释
int *(&array)[10] = pts：按照由内向外的顺序，首先知道array是个引用，然后观察右边知道array引用的对象是一个大小为10的数组，最后左边知道，数组的类型是指向int的指针。

### sizeof操作符
sizeof操作符返回的是某种类型的对象占用内存的字节数。普通指针的类型的对象存储指针值，在32位系统中是4个字节，在64位系统中是8个字节。内置数组尽管可以隐士转换为指针，但本身不是指针类型。如果sizeof作用于数组，将返回整个数组的所占内存的大小；比如内置数组的别名`typedef int Arr[10];`，而指针的别名位`typedef int* Ptr;`。如果要定义一个指向内置数组的指针，则`int (*ptr)[10] = &arr;`

### union和结构体的区别与联系？
联合体是几个不同类型的变量共占一段内存，它们不能同时存在；结构体把不同类型的数据组合成一个整体，各成员都占有自己的内存空间，它们是同时存在的。所在任何同一时刻, union中只存放了一个被选中的成员, 而struct的所有成员都存在。对于union的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于struct的不同成员赋值是互不影响的。一个struct变量的总长度和所有成员长度有关。Union变量的长度等于最长的成员的长度。

### 引用声明为null的空指针会触发什么操作？
解引用空指针时，会导致程序崩溃（Segmentation fault）。

### C++ 内存回收
C++ 将内存划分为三个逻辑区域：栈、堆和静态存储区，相应的对象称为栈对象、堆对象和静态对象。

栈空间是高地址向低地址增长，一般用于存放局部变量。由编译器管理对象的分配和释放。栈空间中的对象具有“先进后出”的特点，即先分配的对象，后释放。这种“先进后出”的特点使得栈空间的可用区域是一块连续的区域。我们可以通过将一个类的析构函数声明为 private 的方式阻止在栈空间上创建对象，不过需要提供额外的对象释放函数。

堆空间又叫自由存储区，由低地址向高地址增长。程序在执行的过程中可以动态地从对空间申请对象，在不需要的时候程序显式地释放对象。也就是说，所有堆对象的创建和销毁都需要由程序员自己负责。堆对象的管理是一件棘手的事情，如果分配了堆对象却忘记了释放，就会产生内存泄漏；而如果一个指针所指的对象已经释放掉，再次解引用该指针，其行为是未定义的。可以使用智能指针简化多态内存的管理。我们可以通过将 operator new 和 operator delete 函数重载为私有阻止一个对象在堆空间创建。

静态对象保存在静态存储区，局部静态对象的生命周期从其所在函数第一次被调用开始，直到整个程序结束时，才销毁该对象。更准确地说，是当第一次执行到该静态对象的定义代码时，产生静态局部对象。对于类的静态成员，在其第一个对象定义是静态成员产生。

### C++ RAII 机制
RAII 的意思是资源获取就是初始化，是 C++ 语言的一种管理资源、避免泄漏的手法。在使用系统资源的时候，都必须遵循统一的步骤：申请-使用-释放。RAII 机制就是管理对象在构造函数中获得资源，在析构函数中释放管理的资源。不论控制流如何离开区块，一旦管理对象被销毁，其析构函数自然会被自动调用，于是资源被释放。如此，就不用显式地申请和释放资源了。

## 关键字

### const 关键字的作用  
1. 欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了
2. 对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const
3. 在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值
4. 对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变
5. 对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值“; 

### static关键字的作用
1. 修饰局部变量。该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束（初始化只进行一次）；虽然用static对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块
2. 修饰全局变量。对于一个全局变量，它既可以在本源文件中被访问到，也可以在同一个工程的其它源文件中被访问(只需用extern进行声明即可)
3. 修饰函数。用static修饰函数的话，情况与修饰全局变量大同小异，就是改变了函数的作用域
4. 在class内的static全局变量可以被class内所有函数访问，但不能被class外其他函数访问，对类的所有对象只有一份复制
5. 在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量  

### extern关键字的作用
1. extern可置于变量或者函数前，以表示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。另外，extern也可用来进行链接指定
2. 修饰函数。如果函数的声明中带有关键字extern，仅仅是暗示这个函数可能在别的源文件里定义，没有其它作用
3. extern “C”。 C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。  

### volatile关键字的作用
- 易变性：当遇到 volatile 修饰的变量，只能从变量的内存地址读取这个变量，不可以从缓存、寄存器或者其他地方读取。
- 不可优化：编译器不能对 volatile 修饰的变量进行各种激进的优化，甚至将变量直接删除，要确保代码中的指令一定会被执行
- 顺序性：volatile 变量间的顺序性，编译器不会进行乱序优化（只保证编译不乱序，不保证执行不乱序）
- 一个参数可以即是const又是volatile的吗？可以，一个例子是只读状态寄存器，是volatile是因为它可能被意想不到的被改变，是const告诉程序不应该试图去修改他 

## 虚函数与多态

### 多态的实现方法都有哪几种
- 重载
  - 如果同一作用域（一个类就是一个作用域，具有继承关系的类是在不用的作用域）的几个函数名字相同但形参列表不同（参数个数、类型、顺序），称之为函数重载
  - 在C++的底层，有重命名机制，比如下面这个函数。底层的重命名机制将函数根据参数的个数，参数的类型，返回值的类型都做了重新命名。在底层，不同的重载类型具有不同的函数名。
- 模板
  - 所谓函数模板，实际上是建立一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟的类型来代表。这个通用函数就称为函数模板。在调用函数时系统会根据实参的类型来取代模板中的虚拟类型，从而实现了不同函数的功能。
- 虚函数（覆盖或重写）
  - 派生类中的函数只有与基类虚函数的调用形式一样（有一个例外，返回对象本身的指针或应用）才构成覆盖（重写）
  - 具有虚函数的类，有一个指针，通常称为`vptr`，指向一个某表格（virtual table）。表格中持有类的虚函数地址。这些地址在编译时确定，是固定不变的。每个虚函数都被指派一个表格索引值。比如说，有这么一个例子：
  ```
  base_ptr->z();
  ```
  每次调用z()时，我们并不知道base_ptr指向的真正类型。然而我们知道，经过base_ptr可以存取到该对象的virtual table。并且，在表格特定的偏移处，有z()的地址。比如说是在slot 4中，则编译器可以将上述调用转换为：
  ```
  (*base_ptr->vptr[4](base_ptr));
  ```
  执行期唯一确定base_ptr，不同的base_ptr调用不同的实例。

### 静态函数和虚函数调用时的区别

## STL

### STL迭代器类型
有五种迭代器
- 输入迭代器（Input Iterator）：只能读取迭代器指向的元素，并且迭代器只能++（不能访问遍历过的元素）
- 输出迭代器（Output Iterator）：可以改变迭代器指向的元素，并且迭代器只能++
- 前进迭代器（Forward Iterator）：只能++，但是可以多次访问
- 双向迭代器（Bidirectional Iterator）：可以++和--
- 随机访问迭代器（Random Iterator）：可以随机访问

### vector list map 介绍一下，并说vector和list有什么不同
vector的底层是数组，是一段连续的地址空间，list底层是链表，节点间的地址空间不连续，map的底层是红黑树。

### vector内存是怎么增长的
当向vector插入元素并且预分配的内存空间用完时，vector会重新申请一块更大的内存空间，其大小是当前大小的两倍。接着将待插入的元素插入到新的内存的适当位置处。然后讲原来的元素复制到新的空间。如果在拷贝的过程中出现异常，已经拷贝的元素会被析构，新申请的内存会被释放。最后释放原来的内存空间。

### map里面为什么要用红黑树
可以在O(logn)时间内完成查找、插入和删除

### vector迭代器失效的情况
vector的迭代器是指针的封装，当vector空间不足，重新申请内存是，指向原来内存的迭代器（指针）将失效

## C++11

### C++11了解吗？说一下智能指针
以引用计数为基础的智能指针，引用计数的工作方式如下
- 除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少个对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将引用计数初始化为1
- 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户所共享
- 析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态
- 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户了，拷贝运算符就必须销毁状态
- 计数器一般保存在动态内存中。当创建一个对象时，也分配一个新的计数器。当拷贝或赋值对象时，拷贝指向计数器的指针。使用这种方法，副本和原对象都会指向相同的计数器

### default 和 delete
C++ 的类有一些特殊的成员函数，比如说默认构造函数、拷贝构造函数、移动构造函数、拷贝赋值运算法、移动赋值运算符以及析构函数，这些函数是拷贝控制操作（除了默认构造函数），控制该类的对象拷贝、赋值或销毁时做什么。如果程序员没有显式地为一个类定义某个特殊成员函数，而又需要用到该特殊成员函数时，编译器会隐式地为这个类生成一个默认的特殊成员函数。其中默认构造函数只在没有定义任何构造函数又需要时才会创建。

= default 的含义是显式的要求编译器生成构造函数（只能是默认构造函数和拷贝控制操作）。其中，= default 既可以和声明一起出现在类的内部，也可以作为定义出现类的外部。和其他函数一样，如果 = default 来类的内部，则内联函数；如果它在类的外部，则该成员函数默认情况下不是内联的。

= delete 的含义是将某个函数定义为删除的函数。删除的函数是这样的一种函数，随让我们声明了它们，但不能以任何方式使用他们。在函数的参数列表后面加上 = delete 来指出我们希望将它定义为删除的。另外，我们可以将某个函数声明为 private 或 protected，但是不定义它们，其效果与 = delete 相同。与 = default 不同，= delete 必须出现在函数第一次声明的时候。另外，我们可以对任何函数（除了析构函数）指定 = delete。值得注意的是，我们不能删除析构函数。如果析构函数被删除，就无法销毁此类型的对象。对于一个删除了析构函数的类型，无法在栈空间定义该对象，但是可以在堆空间创建该对象，但是必须提供对象释放函数。

与拷贝操作不同，编译器根本不会为某些类合成移动操作。特别是，如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符。只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非 static 数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。与拷贝操作不同，移动操作永远不会隐式定义为删除的函数。但是，如果我们显式地要求编译器生成 = default 移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。

某些类不能依赖于合成的默认构造函数
- 编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数，一旦我们定义了其他的构造函数，除非我们在定义一个默认的构造函数，否则类将没有默认构造函数
- 合成的默认构造函数可能执行错误的操作（指针和数组默认初始化，其值是未定义的）
- 有的时候编译器不能为某些类合成默认的构造函数，例如类的某个数据成员没有默认构造函数，那么编译器就没法合成默认构造函数。

合成的拷贝控制成员可能是删除的（如果一个类有数据成员不能默认构造、拷贝、复制或者销毁，则对应的成员函数被定义为删除的）
- 合成的析构函数被定义为删除的情况
  - 类的某个成员的析构函数是删除的或是不可访问的
- 合成的合成拷贝构造函数被定义为删除的情况
  - 类的某个成员的拷贝构造函数是删除的或不可访问的
  - 类的某个成员的析构函数是删除的或是不可访问的
- 合成的拷贝赋值运算符被定义为删除的情况
  - 类的某个成员的拷贝赋值运算符是删除的或不可访问的
  - 类有一个 const 或引用成员
- 合成的默认构造函数被定义为删除的情况
  - 某个成员的析构函数是删除的或不可删除的
  - 类有一个引用成员，没有类内初始化器
  - 类有一个 const 成员，没有类内初始化器其其类型未显式定义默认构造函数
- 合成的移动构造函数被定义为删除的情况
  - 有类成员定义了自己的拷贝构造函数且未定义移动构造函数
  - 有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数
  - 有类成员的移动构造函数被定义为删除的
  - 类的析构函数被定义为删除的
- 合成的移动赋值运算符被定义删除的情况
  - 有类成员的移动赋值运算符被定义为删除的
  - 有类成员是 const 或是引用

## 设计模式
### 了解过那些设计模式？

### 那我问你点简单的，讲讲工厂和抽象工厂吧

### 面向对象设计原则 (S.O.L.I.D)  
|简写|全拼|中文翻译|备注|
|:-:|:-:|:-:|:-:|
|SRP|The Single Resoposibility Principle|单一责任原则|修改一个类的原因只有一个（一个类负责一件事）|
|OCP|The Open Closed Principle|开放封闭原则|类应该对扩展开放，对修改关闭|
|LSP|The Liskov Substitution Principle|里氏替换原则|子类对象必须能够替换掉所有父类对象|
|ISP|The Interface Segregation Principle|接口分离原则|不应该强迫客户依赖于他们不用的方法|
|DIP|The Dependency Inversion Principle|依赖倒置原则|高层模块不应该依赖底层模块，二者都应该依赖于抽象;<br>抽象不应该依赖于细节，细节应该依赖于抽象|