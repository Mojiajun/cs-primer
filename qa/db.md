# 数据库相关问题
## 原理
### 事务的性质（ACID）
- 原子性（Atomicity）：事务的操作要么全部提交成功，要么全部失败
- 一致性（Consistency）：一致性是指数据处于一种语义上的有意义且正确的状态。一致性是对数据可见性的约束，保证在一个事务中的多次操作的数据中间状态对其他事务不可见的。因为这些中间状态，是一个过渡状态，与事务的开始状态和事务的结束状态是不一致的。
- 隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其他事务是不可见的
- 持久性（Durability）：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失

### 并发一致问题
- 丢失修改：T1和T2两个事务都对一个数据进行修改，T1先修改，T2随后修改，T2的修改覆盖了T1的修改。
- 读脏数据：T1修改一个数据，T2随后读取这个数据。如果T1撤销了这次修改，那么T2读取的数据是脏数据。
- 不可重复读：T2读取一个数据，T1对该数据做了修改。如果T2再次读取这个数据，此时读取的结果和第一次读取的结果不同。
- 幻影读：T1读取某个范围的数据，T2在这个范围内插入新的数据，T1再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

### 数据库的事务隔离级别
- 可串行化：通常保证可串行化调度。一个事务没有被提交之前，其他的线程，只能等到当前操作完成之后，才能进行操作（互斥访问）
- 可重复读：只允许读取已提交数据，而且在一个事务两次读取一个数据项期间，其他事务不得更新该数据。但该事务不要求与其他事务可串行化。
- 已提交读：只允许读取已提交数据，但不要求可重复读。
- 未提交读：允许读取未提交数据

|-|脏读|不可重复读|幻读|
|:-:|:-:|:-:|:-:|
|未提交读|Y|Y|Y|
|已提交读|N|Y|Y|
|可重复读|N|N|Y|
|可串行化|N|N|N|

### 数据库锁机制（乐观锁与悲观锁）
- 悲观锁  
  - 悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。
  - 悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）
  - 在数据库中，悲观锁的流程如下：
    - 在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。
    - 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。
    - 如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。
    - 其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。
- 乐观锁  
  - 乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。
  - 乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。
  
### sql语句的执行过程，写完一条sql语句之后过程是怎样的。
### 怎么加快sql查询？sql优化方法？
### 数据库索引的数据结构？（B树）
### 安全隔离级别设置为序列化，删除更新操作会产生幻读吗（问题记的有点模糊）
### 索引最左原则，模糊查询一定索引失效?

## mysql
### MySQL索引有哪些，基于数据结构的分类一下？基于hash和B+树的有什么区别、复杂度？什么时候要建立索引？