# TCP/IP基础知识

## TCP头部

<img src='./imgs/tcp-header.png'>

## TCP连接建立（三次握手）

<img src='./imgs/tcp-3connection.png'>

1. `CLOSED`：起始点，在超时或者连接关闭进入此状态。这并不是一个真正的状态，而是一个假想起点和终点
2. `LISTEN`：服务器端等待连接的状态。服务器依次调用`socket`、`bind`、`listen`函数之后进入此状态，开始监听客户端发过来的连接请求。此成为被动打开（等待客户端的连接请求）
3. `SYN-SENT`：第一次握手发生阶段，客户端主动打开，发起连接。客户端调用`connet`函数，发送`SYN`分节给服务器，指明对方端口号和自己的初始序列号和最大段大小，然后进入`SYN_SENT`状态，等待服务器端确认（三次握手的第二个报文）。如果服务器不能连接，则进入`CLOSED`状态。TCP规定，`SYN`报文段不能携带数据，但需要消耗掉一个序号。
4. `SYN-RCVD`：第二次握手发送阶段，服务器接收到了客户端的`SYN`分节，此时服务器进入`SYN_RCVD`状态。服务器发送一个`ACK`对收到客户端的`SYN`分节进行确认，同时发送一个`SYN`分节，告诉客户端自己的初始序列号和最大段大小。这个报文也不能携带数据，但是同样要消耗一个序号。
5. `ESTABLISHED`：第三次握手发生阶段，客户端发送一个`ACK`分节对收到服务器的`SYN`进行确认，客户端进入`ESTABLISHED`状态，表明客户端这边以准备好。服务器收到客户端的`ACK`之后进入`ESTABLISHED`状态，表明服务端也准备好，双方可以通信。TCP规定，`ACK`报文段可以携带数据，但是如果不携带数据则不消耗序号。

## TCP连接释放（四次挥手）

<img src='./imgs/tcp-close.png'>

1. `FIN_WAIT_1`：第一次挥手。客户端应用进程首先调用`close`，称该端执行主动关闭。发送`FIN`分节，表示数据发送完毕，终止连接，然后等待对方确认，进入`FIN_WAIT_1`状态。TCP规定，`FIN`分节即使不携带数据，也要消耗一个序号。
2. `CLOSE_WAIT`：第二次挥手。收到这个`FIN`的服务器执行被动关闭，发送`ACK`对收到`FIN`进行确认。`FIN`接收也作为一个文件结束符`EOF`传递给高层的应用进程，表示客户端到服务器的连接释放了。此时进入`CLOSE_WAIT`状态。
3. `FIN_WAIT_2`：执行主动关闭的客户端收到服务端的`ACK`分节，进入此状态，等待服务器发送`FIN`，释放连接。
4. `LAST_ACK`：第三次握手，被动方（服务器端）发送`FIN`分节，释放连接，等待客户端确认，服务器端进入`LAST_ACK`状态。
5. `TIME_WAIT`：第四次握手，客户端发送`ACK`对收到`FIN`进行确认，进入`TIME_WAIT`状态。此时`TCP`连接还没有释放，必须经过2*`MSL`（最长报文寿命）的时间后，才进入CLOSED状态。
6. `CLOSED`：服务器端收到`ACK`后进入`CLOSED`状态，客户端再等待2*`MSL`时间后（期间没有收到服务器的超时重传报文）进入`CLOSED`状态

## TCP连接建立和释放疑难点

1. 初始序列号有什么特殊的要求
   - 初始序列号可被视为一个32位的计数器，该计数器的数值每4微秒加1，此举的目的在于为不同连接分配不同初始序列号，尤其是为同一个连接的两个不同实例分配不同的初始序列号。因为一个TCP连接是被一对套接字所唯一表示，其中包括由两个IP地址和两个端口号构成的4元组，因此即使是同一个连接也会出现不同的实例。
2. SYN分节是否消耗序列号，ACK分节呢，为什么？
   - SYN消耗一个序列号，为了保证可靠传输。ACK不消耗序列号
3. 为什么会有最后一次确认？两次握手不行吗？
   - 最后一次握手是为了防止前两次握手已失效的连接请求分节突然又传到服务端，而产生错误。考虑两次握手下面这种情况：客户端向服务器发出TCP连接请求，第一个SYN分节在网络的某个结点长时间滞留，客户端超时后认为报文丢失，于是再重传SYN分节，服务器收到后建立连接。数据传输完毕后双方断开连接。而此时前一个滞留在网络中的SYN到达服务器，服务器认为客户端又发送连接请求，服务端向客户端返回确认报文，服务器和客户端再次建立连接。服务器一直等待客户端传输数据，而此时客户端并没有连接请求，这导致不必要的错误和资源浪费。若采用三次握手，客户端不理会服务端的确认，服务器收不到客户端的确认，建立连接失败。
4. 为什么不采用三次挥手释放连接，且最后发送最后一次挥手后要等待2MSL的时间呢？
   - 第一为了保证最后一个ACK能够到达B。最后一个ACK分节可能丢失，如果客户端不等待2MSL，可能的结果是服务器超时重传FIN分节，而此时客户端已经关闭，不能发送ACK确认，服务器不能正常释放连接。若客户端等待了2MSL，客户端收到FIN后发送ACK，并且重启计时器，再次等待2MSL。
   - 第二，防止类似“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。
5. 为什么建立连接是三次握手，关闭连接确是四次挥手呢？
   - 建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次
6. 如果已经建立了连接，但是客户端突然出现故障了怎么办？
   - TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

## TCP可靠传输

TCP使用了检验、序号、确认和重传等机制实现可靠传输

### 序号

TCP首部的序号字段用来保证数据能有序地提交给应用进程，TCP把数据看成一个无结构但是有序的字节流，而序号是建立在传送的字节流之上的。TCP连接中传送的数据流中的每个字节都编上一个序号。序号字段的值则指本分节所发送的数据的第一个字节的序号。

### 确认

TCP首部的确认号是期望收到对方的下一个分节的数据的第一个字节的序号。发送方缓存会继续存储那些已经发送但未收到确认的数据，以便在需要的时候（超时）重传。TCP默认使用累计确认，累积确认可以允许TCP延迟一段时间发送ACK，以便将ACR和相同方向上需要传的数据结合发送。

### 重传

TCP拥有两套独立机制来完成重传，一是基于时间，而是基于冗余ACK。TCP在发送数据时会设置一个计时器，若计时器超时仍未收到数据确认，则会引发超时重传。另一种方式的重传成为快速重传，若TCP累计确认无法返回新的ACK，快速重传会推断出现丢包。当TCP超时重传，它并不需要完全重传相同的分节，TCP允许执行重新组包，发送一个更大的分节来提高性能。

#### 超时重传

TCP每发送一个分节，就对这个分节设置一个计时器。标准方法通过记录往返时间(Round-Trip Time, RTT)测量值的变化情况以及均值来得到较为准确的估计值，基于均值和估计值的变化来设置超时重传时间(Retransmission Time-Out, RTO)。考虑到效率等问题，用过平均偏差近似标准差。对每个RTT测量值M，进行如下运算：
```
srtt = (1 - g) * srtt + g * M
rttvar := (1 - h) * rttvar + h * |M - srtt|
RTO = srtt + 4 * rttvar
```
其中g取为1/8，h取为1/4。RTO的初始值为1s，而初始SYN分节采用的超时间隔为3s。当接收到收割RTT测量结果M，估计值按如下方法进行初始化：
```
srtt = M
rttvar = M / 2;
```
一旦TCP发送端得到了基于时间变化的RTT测量值，就能根据此设置RTO，发送分节时应确保重传计时器设置合理。在设定计时器前，需记录被即使的分节的序号，若及时受到了该分节的ACK，那么计时器被取消。若在设定的RTO内，TCP没有收到被计时分节的ACK，将会触发超时重传。当发生这种情况时，TCP通过降低当前数据发送速率来对此进行快速响应。它有两种方法：一是基于拥塞控制机制减小发送窗口大小；另一种是每当一个重传分节被再次重传时，则增大RTO的退避因子。特别地当同一个分节出现多次重传时，RTO暂时乘上y来形成新的超时退避值：`RTO = y * RTO`。在通常情况下，y值为1。随着多次重传，y加倍增长：2，4，8等等。

#### 快速重传（冗余ACK）

快速重传机制基于接收端的反馈信息来引发重传，能更加及时有效地修复丢包情况。TCP规定每当收到失序分节时（收到比期望序号大的分节）时，立即生成确认信息（重复ACK），不能延时发送，及时告知发送端有失序分节并告诉其空缺在哪。失序现象表明在后续数据到达前出现了丢包，发送端应尽快地、高效地填补该空缺。TCP标准规定当发送方收到同一个报文的3个冗余ACK时触发快速重传，而不必等到重传计时器超时。当然也可以同时发送新的数据。

<img src='./imgs/fast-retrans.png'>

## TCP流量控制

### 延迟ACK

TCP并不对每个到来的分节都返回ACK。累计确认可以允许TCP延迟一段时间发送ACK，如果这段时间内有数据发送到对端，则捎带发送ACK，如果在延迟ACK定时器触发时候，发现ACK尚未发送，则立即单独发送；

延迟ACK好处：

- 避免糊涂窗口综合症；
- 发送数据的时候将ACK捎带发送，不必单独发送ACK；
- 如果延迟时间内有多个数据段到达，那么允许协议栈发送一个ACK确认多个报文段；

### Nagle算法

该算法要求，当一个TCP连接中有带确认数据，小的分节（长度小于MSS）就不能发送，知道所有的待确认数据都收到ACK。并且在收到ACK后，TCP需要收集这些小分节，将其整合到一个分节发送。该算法的优越之处在于它是自适应的，ACK返回越快，数据也就发送的越快；在相对高时延的广域网中，更需要减少微小分节的数目，该算使得单位时间内发送的分节数目更少。也就是说，RTT控制着发送速率。

### 滑动窗口

<img src='./imgs/slide-window.png'>

TCP以字节为单位维护其窗口结构。由接收端通告的窗口成为提供窗口。窗口大小字段相对于ACK号有一个字节的偏移量。发送端计算其可用窗口，即它可以立即发送的数据量。可用窗口计算值为提供窗口大小减去在传（已发送但未得到确认）的数值。窗口左边界不能左移，因为它控制的是已确认的ACK号，具有累计性，不能返回。在通信的过程中，接收方根据自己接受缓存的大小，动态地调整发送方的提供窗口大小，同时发送方根据其对当前网络拥塞程度的估计确认拥塞窗口大小，最后发送端的是提供窗口大小和拥塞窗口大小的最小值。当提供窗口大小为零，成为零窗口，此时发送端不能再发送新数据。这种情况下，TCP发送端开始探测对方窗口大小。

## TCP拥塞控制

### 流量控制和拥塞控制

流量控制的目的是消除发送方使接收方缓冲区发生溢出的可能性，是点对点的控制。接收方会根据自己接收缓冲区的大小，动态地调整发送方的发送窗口的大小。它是基于ACK分节中的窗口大小字段来实现的。拥塞控制目的是防止过多的数据注入网络中，造成路由器无法处理高速到达的流量而被迫丢弃数据信息（拥塞），是一个全局性的过程，涉及所有主机、路由器等。两者也有相似的地方，都是通过控制发送方发送数据的速率来达到效果的。

### 慢启动算法

当一个新的TCP连接建立或发生超时重传的丢包，需要启动慢启动，或者发送端长时间处于空闲状态，也可能启动慢启动。慢启动的目的是：在TCP用拥塞避免算法探寻更多可用带宽之前，得到拥塞窗口（congeston window）大小。以帮助TCP建立ACK时钟。通常，TCP在建立新连接时执行慢启动，直至有丢包时，执行拥塞避免算法，进入稳定状态。

在TCP刚刚建立好，开始发送TCP分节时，先令拥塞窗口cwnd=1，即一个最大段大小MSS。而在每收到一个对新的分节的确认后，将cwnd加1，即增大一个MSS。用这样的方法逐步增大发送方的拥塞窗口，可以分节注入网络的速率更加合理。一般情况下，如果成功收到相应的新的ACK，cwnd呈指数增长。

### 拥塞避免

在慢启动阶段，cwnd会快速增长，一旦达到阈值（慢启动阈值，ssthresh），就意味着可能有更多可用的传输资源。但是如果立即全部占用这些资源，将会使共享路由器队列的其他连接出现严重的丢包和重传情况，从而导致整个网络性能不稳定。为了得到更多的传输资源且不至于影响其他连接的传输，改用拥塞避免算法。

拥塞避免算法的做法是：发送端的拥塞窗口cwnd每经过一个往返时延RTT就增加一个MSS的大小，而不是加倍，使cwnd按线性规律缓慢增长（即加法增大），而当出现一次超时（网络拥塞）时，令慢启动门限ssthresh等于当前cwnd的一半（即乘法减小）但不能小于2。

### 网络拥塞的处理

无论在慢启动阶段还是拥塞避免阶段，只要发送方检测到超时事件的发生，就表明网络出现拥塞，就要把慢启动门限ssthresh设置为当前cwnd的一半（但不能小于2），然后就把拥塞窗口cwnd重新设置为1，执行慢启动算法。这样做的目的是：快速减少主机发送到网络中的数据，使得发生拥塞的路由器有足够时间把队列积压的分组处理完毕。

<img src='./imgs/slow-start.png'>

### 快重传和快恢复

快重传和快恢复算法是对慢启动和拥塞避免算法的改进

#### 快重传

冗余ACK也用于网络拥塞的检测（丢包意味着网络可能出现了拥塞），快重传并非取消重传计时器，而是当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的分节，而不必等待那个分节设置的重传计时器超时。

#### 快恢复（Reno版本）

快恢复算法原理：当发送端收到连续三个冗余ACK时，就执行“乘法减小”算法，把慢启动门限ssthresh设置为出现拥塞时发送方cwnd的一半，并且将cwnd设置为新的ssthresh值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。

<img src='./imgs/fast-recovery.gif'>