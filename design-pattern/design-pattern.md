# 设计模式
## UML 类图关系
### 继承



## 介绍
### 什么是设计模式
每一个模式描述啦一个在我们周围不断重复发生的问题以及该问题的解决方案的核心。这样，你就能一次有一次地使用该方案而不必做重复劳动。

### GOF 设计模式
历史性著作《设计模式：可复用面向对象软件的基础》

### 从面向对象谈起
- 底层思维：向下，如何把握机器底层从微观理解对象构造
  - 语言构造
  - 编译转换
  - 内存模型
  - 运行时机制
- 抽象思维：向上，如何将我们的周围世界抽象为程序代码
  - 面向对象
  - 组件封装
  - 设计模式
  - 架构模式

### 深入理解面向对象
- 向下：深入理解三大面向对象机制
  - 封装，隐藏内部实现
  - 继承，复用现有代码
  - 多态，改写对象行为
- 向上：深刻把握面向对象机制多带来的抽象意义，理解如何使用这些机制来表达现实世界，掌握什么是“好的面向对象设计”。

### 如何解决复杂性
- 分解：分而治之
- 抽象：特殊到一般

### 重新认识面向对象
- 隔离变化
- 各司其职
- 对象是什么？
  - 封装了代码和数据
  - 一系列可被使用的公共接口
  - 某种拥有责任的抽象

### 面向对象设计原则（SOLID）
- 依赖倒置原则（DIP）
  - 高层模块（稳定）不依赖与低层模块（变化），二者都应该依赖于抽象（稳定）
  - 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该抽象（稳定）
- 开放封闭原则（OCP）
  - 对扩展开放，对更改封闭
  - 类模块应该是可扩展的，但是不可修改
- 单一职责原则（SRP）
  - 一个类应该仅有一个引起它变化的原因
  - 变化的方向隐含着类的责任
- Liskov 替换原则（LSP）
  - 子类必须能够替换他们的基类
  - 继承表达类型抽象
- 接口隔离原则（ISP）
  - 不应该强迫客户程序依赖他们不用的方法
  - 接口应该小而完备

### 从封装变化角度对模式分类
<img src='./imgs/design-pattern-classification.png'>

## Template Method
### 动机
在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却又很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。

如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？

### 定义
定义一个操作中的算法骨架（稳定），而将一些步骤延迟（变化）到子类中。Template Method 使得子类可以不改变（复用）一个算法的结构即可重定义（override 重写）该算法的某些特定的步骤。

### 结构
<img src='./imgs/template-pattern.png'>

## Strategy
### 动机
- 在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会是对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担;
- 如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解藕，从而避免上述问题？

### 模式定义
定义一系列算法，把他们一个个封装起来，并且使他们可以互相替换（变化）。该模式使得算法可独立于使用它的客户程序（稳定）而变化（扩展，子类化）。

### 结构
<img src='./imgs/strategy.png'>

### 要点总结
- Strategy 及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。
- Strategy 模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解藕合。含有许多条件判断语句的代码通常都需要  Strategy 模式。
- 如果 Strategy 对象没有实例变量，那么各个上下文可以共享同一个 Strategy 对象，从而节省对象开销。

## Observer / Event
### 动机
- 在软件创建过程中，我们需要为某些对象建立一种“通知依赖关系”--一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将是软件不能很好地地域变化。
- 使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。

### 模式定义
定义对象的一种一对多（变化）的依赖关系，以便当一个对象（Subject）的状态发生改变时，所依赖于它的对象都得到通知并自动更新。

### 结构
<img src='./imgs/observer.png'>

### 要点总结
- 使用面向对象的抽象，Observer 模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖达致松耦合。
- 目标发送通知时，无需指定观察者，通知会自动传播。
- 观察者自己决定是否需要订阅通知，目标对象对此一无所知。
- Observer 模式是基于事件的UI框架中非常常用的设计模式，也是 MVC 模式的一个重要组成部分。

## Decorator
### 动机
- 在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性;并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀;
- 如何使“对象功能的扩展”能够根据需要来动态地实现？同时避免“扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能扩展变化”所导致的影响降为最低？


### 模式定义
- 动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator 模式比生成子类（继承）更为灵活（消除重复代码&减少子类个数）。

### 结构
<img src='./imgs/decorator.png'>

### 要点总结
- 通过采用组合而非继承的手法，Decorator 模式实现了在运行时动态扩展对象功能的能力，而且可以根据许啊哟扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题”。
- Decorator 类在接口上表现为 is-a Component 的继承关系，即 Decorator 类继承流 Component 类所具有的接口。但在实现上又表现为 has-a Component 的组合关系，即 Decorator 类有使用了另外一个 Component 类。
- Decorator 模式的目的并非解决“多个子类衍生的多继承”问题，Decorator 模式应用的要点在于解决“主体类在多个方向上的扩展功能”--是为“装饰”的含义。